# DBMS

## DBMSとは

以下の3大機能を実現する、マネジメントシステム
- メタデータ管理
- 質問処理
- トランザクション処理

## メタデータ管理

メタデータには以下のようなものがある。これらはデータディクショナリに格納される。
- どうようなテーブルがあるか (= 外部スキーマ)
- どのような属性があるか (= 概念スキーマ)
- インデックスなどの設定 (= 内部スキーマ)

## インデックスについて

### インデックスの種類

- ユニークインデックス
    - 主キーなどのように、インデックス値に対応するデータが1つだけのもの
- 非ユニークインデックス
    - ユニークインデックスでないもの、キーに対するポインタ (データのある先) を複数持つ
- クラスタ化インデックス
    - インデックスの基本はポインタの管理
    - しかし、ポインタ先のメモリが離れていると、アクセス効率が悪い
    - キーごとにデータの格納場所を整理する (=クラスタ化)する
    - このクラスタ化の対象となるインデックスをクラスタ化インデックスと呼ぶ
- 非クラスタ化インデックス
    - 物理メモリの位置を操作するので、クラスタ化インデックスは1つだけ
    - その他は非クラスタ化インデックス

### インデックスのアルゴリズム
インデックスは、B tree, ビットマップ, hashなどの方法で実現される。

#### B tree

B tree系のものは、特定の1つのデータを探すのに向いており、主キーなどで利用される。複数のインデックスを同時に使うことができない。

- B tree
    - 1つの根ノードから複数の分岐がある木構造。2分探索木のように大小比較で探索する。末端を葉ノードと呼ぶ。
    - データ（キーと値）をすべてのノードに格納する
    - ノード分割は要素数が最大を超えたときに中央要素を親へ昇格
    - 高さが低く抑えられ、ディスクアクセス回数を減らせる
- B+ tree
    - 根ノードはキーだけを持ち、実データはすべて葉ノードに格納する
    - 葉ノードは連結リストで接続されているので、範囲検索が効率的。
    - ルートから葉までの高さはほぼ同じでも、内部ノードにデータがない分、1ノードあたりのキー数が増やせる → 高さがさらに低くなる。
- B* tree
    - ノードに含まれるデータの最低数を最大値の2/3以上とすることで、ディスクI/Oが減り、より効率的な検索が可能。

#### ビットマップ
- 取りうる値の数が少なく、複雑な検索が行われる際に利用
- ビットマップを作成して、それを利用する

#### ハッシュ
- ハッシュを使う。ハッシュ衝突が発生するような大規模なものには向かない

## 性能を挙げるためには

- インデックスの貼り方を工夫する
- 速度や処理時間を計測する
- ディスク容量を計算する (1ブロックの平均バイト*見積行数)
- パーティション分割する

## テーブルの結合アルゴリズム

- 入れ子ループ法
    - 2重ループによって、直積を作成する要領で結合する
    - 行数が多くなると速度が落ちる
- マージジョイン法
    - ２つのテーブルの結合列を予めソートしてから結合する
- セミジョイン法
    - 分散データベースで使われる
    - データベース間でテーブル結合時にはデータを転送する必要がある
    - 必要な属性だけをもう1つのDBに送信
    - 結合に成功したものだけを元のDBに送って最終的に結合する
- ハッシュジョイン法
    - ハッシュ値を生成し、テーブルの比較ではなくハッシュ同士を比較する

## トランザクション処理
DBおいて、1つ以上の操作をまとめて単一の処理として実行する単位をトランザクションとと呼ぶ。不整合検索異常 (不整合によって誤った結果を返すこと) を防ぐために、トランザクション間の整合性を保つ必要がある。

### ACID特性

- **原子性 (Atomicity)**: トランザクションは全ての操作が成功するか(COMMIT)、一切成功しない(元に戻す/ROLLBACK) かのいずれかとなる。途中でエラーが発生した場合、全ての変更を取り消して元の状態に戻す。
- **一貫性 (Consistency)**: トランザクションの開始前と終了後でデータベースは一貫性がある状態を維持する。直接化可能性 (Serializability) を満たす必要がある。
- **隔離性 (Isolation)**: 複数のトランザクションが同時に実行されても、各トランザクションは互いに影響を与えず、完了するまで他のトランザクションはその変更を見られない。。
- **耐久性 (Durability)**: トランザクションが完了すると、その結果は永続的であり、データベースの障害が発生しても保持される。

### トランザクションの制御方法

- 排他制御: 処理を排他的になるよう制御する。ロックが一般的。
- 同時実行制御
    - 楽観的制御法: とりあえず更新して完了時点で他トランザクションが更新していなければOKとする
- 多版同時実行制御 (MVCC): データ書き込み時に新しい版を作成する。タイミングによって前の版のデータを返すなどする

### ロック

#### ロックの種類

ロックには以下の種類がある。
- **共有ロック**: 複数のトランザクションが同時に読み取りアクセスすることを許可する。書き込みアクセスは禁止。
- **排他/占有ロック**: トランザクションがデータを更新するときに使用される。他のトランザクションが同時に共有ロックや排他ロックを取得できない。

ロックの粒度には、行ロックとテーブルロックがある。

#### 直列化可能性
- トランザクションの並行スケジュールが、ある直列スケジュール（1つずつ順番に実行するスケジュール）と同じ結果を生むとき、そのスケジュールは直列化可能である
- ロックが発生すると、直列化可能性を満たせない場合がある

#### 二相ロック

- 直列化可能性を保証するロック方式
- 読み書きに必要な全てのロックが完了するまでアンロックしない
- ロックをかけ続ける単調増加の相とアンロックをする単調減少の相の意

#### トランザクションの分離レベル

トランザクションの独立性のレベルを分離レベルとよび、業務に最適なものを選択する。 上のものほど分離レベルが低い。

- READ_UNCOMMITTED: 変更途中のデータを読み取れる (dirty read)
- READ_COMMITTED: commitされたものだけ読み取れる。commit前後で読み込んだ値が変化しうる (unrepeatable read)
- REPEATABLE_READ: 1つのトランザクション中ではデータが更新されることはない。呼び出したデータ以外は更新されうるので、追加されたデータが見えるようになる (fantom read)
- SERIALIZABLE: 必ず直列化可能性を満たすが並列性に難あり。

## 障害復旧

- データが更新された際には、メモリ上でデータを管理し、一定タイミング (チェックポイント) でハードウェアに書き込む
- DB更新時には、2つのログが保存される
    - 更新前ログ: DB更新時に、更新前の状態を保存したログ
    - 更新後ログ: DB更新時に、更新後の状態を保存したログ
- ログも、一時的にログバッファに保存され、適当なタイミングでログバッファに保存される
- ロールバック・ロールフォワードは、それぞれ更新前ログ・更新後ログを利用する


## 分散データベース

### CAP定理
分散DBでは、ACID特性につけて、以下2つを満たしたい。
- 可用性 (Availability): 特定のところでエラーがあっても稼働し続ける
- 分断耐性 (Partition-tolerance): DB間が通信障害で分断されても稼働し続ける

しかし、Consistency, Availabilty, Partition-toleranceの3つのうち、同時には2つしか満たせない。
これをCAP定理と呼ぶ。

### 透過性

データが分散していることをユーザーに意識させないよう、透過性を実現する必要がある。

- 位置透過性: どこのDBに格納されていても見られる
- 分割透過性: データが分割して保存されていても一緒に見られる
- 複製透過性: データが複製され別々に保存されていても1津のデータにアクセスしているように見れる

### 2コミット

- 第1相
    - ユーザーからのリクエストを調停者がうけつけ、各システムにコミット要求をする
    - 1つでもNGが返れば、全てにロールバックさせる
- 第2相
    - 全てからOKが来たらコミット指示を出す
    - このタイミングで障害が場合は、ロールフォワードで復旧する
    - 第2相の指示が車での間は、調停者以外のDBはcommitもrollbackもできない (secure状態)

### シャーディング

- データを分割する際に、シャード呼ばれる小さいチャンクで分割し、複数のDBサーバーに保存する
- 分割ルールは予め決めておく
- 行で分割 (水平方向) と列で分割 (垂直分割) がある